# Vibe Coding 性能优化技巧

> 让你的应用跑得更快



你好，我是鱼皮。

在 Vibe Coding 中，你可能遇到过这样的情况：用 AI 做出来的应用，功能都正常，但就是有点慢。比如页面加载要等好几秒、点击按钮半天没反应、滚动列表卡卡的。不仅用户体验不好，自己用着也不爽。

这就是性能问题，AI 生成代码的常见问题之一。因为 AI 更关注 “能不能跑”，而选择性忽略 “跑得快不快”。在 Vibe Coding 中，我们追求的是快速实现功能，但不代表要牺牲性能。还好，性能优化同样可以借助 AI 来完成。

下面，我就来教你如何在 Vibe Coding 中识别性能瓶颈，以及如何让 AI 帮你优化性能。即使你不懂技术原理，也能让应用跑得更快。



## 一、识别性能问题

优化之前，先要知道问题在哪里。

首先要知道，性能不是一个抽象的概念，而是用户的真实感受。用户关心的是：页面打开快不快？点击按钮响应快不快？滚动流畅不流畅？

如今，用户对性能的要求越来越高。如果你的页面加载超过 3 秒，用户可能就会离开。如果点击按钮后没有立即反馈，用户会以为页面卡住了。

所以，优化性能的第一步是站在用户的角度，感受应用的速度。



### 使用性能测试工具

除了主观感受，还要用工具来客观测量。不用担心，这些工具都很简单，不需要编程基础。

1）浏览器开发者工具

按 F12 打开开发者工具，切换到 Performance 性能标签，点击录制按钮，然后操作你的应用，最后停止录制。你会看到一个详细的性能报告，包括每个操作花了多少时间，哪些函数最慢，有没有卡顿等。

![](https://pic.yupi.icu/1/image-20260105150358449.png)

如果你看不懂这些数据，没关系，可以截图给 AI，让它帮你分析：

```markdown
这是我的性能报告截图，请帮我找出性能瓶颈在哪里。
```



2）Lighthouse

Chrome 自带的性能测试工具。在开发者工具的 Lighthouse 标签，点击 "分析网站加载情况"，它会给你的页面打分，并提供优化建议。

![](https://pic.yupi.icu/1/image-20260105150513178.png)

重点关注这几个指标：

- LCP（Largest Contentful Paint）：最大内容绘制时间，应该在 2.5 秒内
- FID（First Input Delay）：首次输入延迟，应该在 100 毫秒内
- CLS（Cumulative Layout Shift）：累积布局偏移，应该小于 0.1

![](https://pic.yupi.icu/1/image-20260105150756392.png)



3）其他在线工具

还可以用 PageSpeed Insights、GTmetrix 等在线工具测试你的网站，它们会从真实用户的角度测试性能。



### 找到性能瓶颈

测试后，你会发现一些慢的地方。不要急着优化所有问题，先找到最严重的瓶颈。

一般来说，AI 生成的代码性能瓶颈在这几个地方：

- JavaScript 文件太大，加载慢
- API 请求太慢，或者请求太多
- 渲染逻辑复杂，导致页面卡顿
- 数据库查询慢，或者查询太多
- 引用的资源太大，没有压缩和优化

找到瓶颈后，优先优化影响最大的那个。你可以直接把测试结果和代码一起发给 AI，让它帮你定位问题：

```markdown
我的应用加载很慢，这是性能测试结果【贴测试结果】，这是相关代码【贴代码】，请帮我找出问题并给出优化方案。
```




## 二、常见性能瓶颈

基于我的经验，这里总结了一些 AI 生成代码时容易出现的性能瓶颈。了解这些问题，能帮你更好地引导 AI 生成高性能的代码。



### 不必要的重新渲染

在前端开发框架（比如 React）中，组件会因为各种原因重新渲染。如果渲染太频繁，页面就会卡。

AI 生成的代码可能会忽略这个问题，因为它更关注功能实现。常见的原因是：父组件更新时，所有子组件都会重新渲染，即使它们的数据没变。每次渲染都创建新的函数或对象，导致子组件认为数据变了。状态更新太频繁，比如在输入框的每次输入都触发复杂计算。

如何让 AI 帮你优化？

你可以这样告诉 AI：

```markdown
这个组件渲染太频繁，页面很卡。请帮我优化，使用 React.memo、useMemo 和 useCallback 来减少不必要的渲染。
```

即使你不懂这些技术名词，直接跟 AI 说 “这个页面很卡”，AI 也会帮你做好优化。



### 大量数据的渲染

如果要渲染一个很长的列表，比如 1000 条数据，AI 可能会直接把所有数据一次性渲染出来，导致页面很慢。

如何让 AI 帮你优化？

告诉 AI 你的具体需求：

```markdown
我有一个 1000 条数据的列表，全部渲染太慢了。请帮我实现虚拟滚动，只渲染可见的部分。
```

或者：

```markdown
请帮我实现分页功能，一次只显示 20 条数据。
```

AI 会给你完整的实现方案，包括相关的库推荐（比如 react-window）和代码示例。



### 图片未优化

图片一般是页面最大的资源。AI 在生成代码时，往往会直接使用原始图片，不会主动优化。

你可以让 AI 帮你实现图片优化：

```markdown
请帮我实现图片懒加载功能，只有图片进入视口时才加载
```

或者：

```markdown
请帮我把图片改成 WebP 格式，并添加压缩处理
```

对于图片压缩，你可以使用在线工具（比如 [TinyPNG](https://tinypng.com/)），或者让 AI 帮你写个程序，来实现自动化的图片处理流程。



### 同步的 API 请求

AI 生成完整的前后端代码时，一般会按照最直观的方式实现，也就是前端一个请求接一个请求调用后端。这样一来，请求总时间就是所有请求时间的总和，会比较慢。

比如下面这段代码：

```typescript
// AI 最初可能生成的：串行请求（慢）
const user = await fetchUser();
const posts = await fetchPosts();
const comments = await fetchComments();
// 总时间 = t1 + t2 + t3
```

如果你发现了这个问题，可以告诉 AI：

```markdown
这几个 API 请求是独立的，请帮我改成并行请求，减少总等待时间。
```

AI 会帮你改成这样：

```typescript
// 优化后：并行请求（快）
const [user, posts, comments] = await Promise.all([
  fetchUser(),
  fetchPosts(),
  fetchComments()
]);
// 总时间 = max(t1, t2, t3)
```

就是这样一个小优化，说不定能让页面的加载速度提升 2 ~ 3 倍。



### 缺少缓存

缓存就像是把常用的东西放在手边，下次用的时候不用再去远处拿。比如你第一次查询用户信息需要 1 秒，如果把结果缓存起来，下次再查询同一个用户，0.01 秒就能拿到结果。

![](https://pic.yupi.icu/1/cacheusage%E5%A4%A7.jpeg)

AI 生成的代码一般不会主动添加缓存机制，导致每次都要重新获取相同的数据，浪费时间。

你可以这样告诉 AI：

```markdown
这个数据每次都要重新获取，太慢了。请帮我添加缓存，把数据缓存 5 分钟。
```

或者

```markdown
请帮我实现一个简单的内存缓存，避免重复请求相同的数据。
```

AI 会根据你的场景选择合适的缓存方案，比如浏览器缓存、内存缓存或者 CDN。



## 三、前端性能优化

前端性能直接影响用户体验，我们重点讲一下。这部分内容对于有编程基础的朋友会更有帮助，如果你是零基础，可以把这些优化需求直接告诉 AI，让它帮你实现。




### 代码分割

AI 生成的代码可能会把所有功能打包成一个大文件，用户打开页面时要下载整个文件，很慢。

你可以告诉 AI：

```markdown
我的 JavaScript 文件太大了，请帮我实现代码分割，把管理面板的代码独立出来，只有用户访问时才加载。
```

AI 会帮你改成这样：

```typescript
// AI 最初可能生成的：一次性导入
import AdminPanel from './AdminPanel';

// 优化后：懒加载
const AdminPanel = lazy(() => import('./AdminPanel'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <AdminPanel />
    </Suspense>
  );
}
```

这样，只有用户访问管理面板时，才会加载相关代码，首页加载速度可能提升 50% 以上。



### 优化渲染性能

如果 AI 生成的代码使用了 React 框架，那么 “渲染” 可能会成为瓶颈。

优化方法包括：

1）使用 `React.memo` 避免不必要的渲染。比如一个展示用户信息的组件，如果用户信息没变，就不需要重新渲染：

```typescript
const UserCard = React.memo(({ user }) => {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
});
```

2）使用 `useMemo` 缓存计算结果。如果有复杂的计算，不要每次渲染都重新计算：

```typescript
function TodoList({ todos }) {
  // 不好：每次渲染都重新计算
  const completedCount = todos.filter(t => t.completed).length;
  
  // 好：只在 todos 变化时重新计算
  const completedCount = useMemo(
    () => todos.filter(t => t.completed).length,
    [todos]
  );
  
  return <div>已完成：{completedCount}</div>;
}
```

3）使用 `useCallback` 缓存函数。避免每次渲染都创建新函数：

```typescript
function TodoList({ todos, onDelete }) {
  // 不好：每次渲染都创建新函数
  const handleDelete = (id) => {
    onDelete(id);
  };
  
  // 好：缓存函数
  const handleDelete = useCallback((id) => {
    onDelete(id);
  }, [onDelete]);
  
  return <div>{/* ... */}</div>;
}
```



### 优化资源加载

减少首次加载的资源大小和数量。

1）压缩资源：使用 Gzip 或 Brotli 压缩 JavaScript、CSS 等文本文件。现代的构建工具（如 Vite、Next.js）一般会自动做这个。

2）Tree Shaking：移除未使用的代码。确保你的构建工具开启了 Tree Shaking，只打包实际用到的代码。

3）预加载关键资源：对于首屏需要的资源，可以预加载：

```html
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
```

4）延迟加载非关键资源：对于不是立即需要的资源，可以延迟加载：

```html
<script src="/analytics.js" defer></script>
```



### 优化 CSS

CSS 也会影响性能，这是比较容易被忽略的点。

1）避免复杂的选择器：复杂的 CSS 选择器会让浏览器花更多时间匹配元素。尽量用简单的类名。

2）减少重排和重绘：修改 DOM 会触发重排（reflow）和重绘（repaint），很消耗性能。尽量批量修改 DOM，而不是一个一个改。

3）使用 CSS 动画而不是 JavaScript：CSS 动画由浏览器优化，比 JavaScript 动画更流畅。

💡 如果你想要更进一步学习前端性能优化，可以看 [鱼皮的前端性能优化实战视频教程](https://www.bilibili.com/video/BV1Wi33zmEAn/)。



## 四、后端性能优化

后端性能决定了 API 的响应速度。同样，这些优化都可以通过 AI 来实现，你只需要描述清楚需求就好。




### 数据库查询优化

数据库查询往往是后端最慢的部分。AI 生成的数据库查询代码通常比较简单直接，可能会有性能问题。

如何让 AI 帮你优化呢？提供几个思路：

1）让 AI 添加索引

```markdown
用户表的 email 字段查询很慢，请帮我添加索引。
```

AI 会给你具体的 SQL 语句或 ORM 配置。



2）避免 N+1 查询

这是 AI 生成代码时最容易出现的性能陷阱。比如你要获取 10 篇文章和它们的作者信息，AI 可能会生成这样的代码：

```typescript
// AI 可能生成的：N+1 查询（慢）
const posts = await db.posts.findMany(); // 1 次查询
for (const post of posts) {
  post.author = await db.users.findOne({ id: post.authorId }); // N 次查询
}
// 10 篇文章 = 11 次查询
```

你可以告诉 AI：这段代码查询太多次了，请优化成一次查询。

AI 会帮你改成：

```typescript
// 优化后：一次查询（快）
const posts = await db.posts.findMany({
  include: { author: true }
});
// 10 篇文章 = 1 次查询
```

这个优化能让接口响应速度提升 10 倍以上。



3）只查询需要的字段

告诉 AI：

```markdown
请只查询需要的字段，不要用 SELECT *，减少数据传输量。
```

AI 会帮你优化查询语句。



### 使用缓存

使用缓存能大大提高响应速度。

1）内存缓存：把常用的数据缓存在内存里，比如用户信息、配置数据等。可以用 Redis 内存存储或者简单的 Map。

2）HTTP 缓存：设置合适的 Cache-Control 响应头（HTTP 头是服务器告诉浏览器如何处理资源的指令），让浏览器缓存静态资源

```typescript
// 静态资源：缓存一年
res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');

// API 数据：缓存 5 分钟
res.setHeader('Cache-Control', 'public, max-age=300');
```

3）CDN 缓存：CDN（内容分发网络）就像在全国各地开了很多仓库，用户访问时从最近的仓库拿资源，比从总部拿要快得多。使用 CDN 来缓存和加速静态资源的分发，能大幅提升全球用户的访问速度。

![](https://pic.yupi.icu/1/image-20260105153947917.png)




### 异步处理

不要让用户等待耗时的操作。

举个例子，用户上传了一张图片，需要生成缩略图。不要让用户等待生成完成，而是：

1. 立即返回成功响应
2. 在后台异步生成缩略图
3. 生成完成后更新数据库

这样用户体验会好很多。




### API 设计优化

好的 API 设计也能提高性能。

1）批量操作：如果要删除多个项目，不要发送多个请求，而是一次性发送：

```typescript
// 不好：多次请求
for (const id of ids) {
  await deleteItem(id);
}

// 好：批量请求
await deleteItems(ids);
```

2）分页和游标：大量数据不要一次性返回，而是使用分页或游标分批返回。

分页就像翻书，一页一页看；游标就像书签，记住你看到哪里了，下次从那里继续。你可以通过 [这篇文章](https://www.codefather.cn/post/1823563686797688834) 进一步了解游标机制。

3）GraphQL：GraphQL 是一种查询语言，让客户端可以精确地指定需要哪些数据，而不是服务器返回一堆用不到的数据。就像点菜时可以自己选配菜，而不是只能点套餐。




## 五、Vibe Coding 性能优化实战

让我用几个真实的案例，展示如何在 Vibe Coding 中通过 AI 来优化性能。这些案例都是我在实际项目中遇到的问题。



### 案例一、慢速列表

问题：我用 AI 做了一个文章列表页面，加载 100 篇文章时很慢，页面卡顿。

我的做法：

1）先用 Performance 工具测试，发现渲染 100 个文章卡片组件花了 2 秒

2）截图测试结果，连同代码一起发给 AI：

```markdown
这个列表页面很卡，这是性能测试结果【截图】，这是代码【代码】，请帮我优化。
```

3）AI 给出了优化方案：使用虚拟滚动、React.memo、图片懒加载

4）我让 AI 直接实现这些优化：

```markdown
请帮我实现虚拟滚动，使用 react-window 库。
```

5）测试优化效果，确认没问题

最后，页面加载时间从 3 秒降到 0.5 秒，滚动变得流畅，整个优化过程不到 10 分钟。



### 案例二、慢速搜索

问题：我用 AI 实现了搜索功能，但搜索很慢，用户每输入一个字符，都要等半秒才能看到结果。

我的做法：

1）通过浏览器的开发者工具观察发现，每次输入都触发了 API 请求

2）我告诉 AI：

```markdown
搜索太慢了，每次输入都发请求。请帮我优化，用户停止输入 300ms 后再发送请求，并且取消之前的请求。
```

3）AI 实现了 debounce 防抖（等用户停止输入后再发请求）和 AbortController（取消之前的请求，避免浪费资源）

4）我又让 AI 添加缓存：

```markdown
请添加搜索结果缓存，相同的搜索词不要重复请求。
```

最后，搜索变得流畅，不再卡顿，API 请求减少了 80%，节省了后端资源。



### 案例三、慢速首页

问题：我用 AI 做的网站首页加载很慢，要等 5 秒才能看到内容。

我的做法：

1）用 Lighthouse 测试，发现 JavaScript 文件太大（2MB），而且图片没有优化

2）把 Lighthouse 报告截图发给 AI：

```markdown
这是我的性能测试报告【截图】，请帮我优化。
```

3）AI 给出了一系列优化建议，我逐个让它实现：

- 请实现代码分割，把不必要的代码延迟加载
- 请帮我压缩图片，使用 WebP 格式
- 请配置 CDN 加速静态资源
- 请启用 Gzip 压缩

4）每次优化后都测试效果，确保有改善

最后，首页加载时间从 5 秒降到 1.2 秒，Lighthouse 评分从 45 提升到 90+，用户明显感觉快了很多。



## 六、Vibe Coding 性能优化的原则

在 Vibe Coding 中优化性能时，要遵循一些基本原则。这些原则能帮你更高效地利用 AI。



### 先测量，再优化

不要凭感觉优化，要用工具测量。很多时候，你以为慢的地方其实不慢，真正的瓶颈在别处。

在 Vibe Coding 中，测量尤其重要。因为 AI 可能会给你很多优化建议，但不是所有建议都值得实施。先测量，找到真正的瓶颈，然后让 AI 针对性地优化，这样效率最高。



### 优化关键路径

不是所有地方都需要优化。优先优化用户最常用的功能，以及对性能影响最大的地方。比如首页加载、核心功能的响应速度等。



### 平衡性能和可读性

性能优化有时会让代码变复杂。你要在性能和可读性之间找到平衡。如果一个优化只能提升 10ms，但让代码难以理解，那可能不值得。



### 不要过早优化

在项目早期，不要花太多时间优化性能。先把功能做出来，等有了真实用户和数据，再根据实际情况优化。过早优化可能会浪费时间，因为你不知道真正的瓶颈在哪里。

这一点在 Vibe Coding 中尤其重要。因为 AI 能快速实现功能，你可能会忍不住想把所有细节都优化到完美。但记住，先让应用跑起来，有用户用了，再优化。MVP 思维同样适用于性能优化。



### 持续监控

性能不是优化一次就够了。随着功能增加，新的性能问题会出现。建议使用性能监控工具（比如 Sentry、LogRocket），持续监控应用的性能，及时发现和解决问题。



## 七、如何让 AI 帮你优化性能？

如果前面的很多技术你都没有接触过、也听不懂，那么可以完全通过 Vibe Coding 来优化性能。完整流程是这样的：




### 1、让 AI 分析性能问题

把代码和测试结果一起发给 AI，让它帮你分析：

```markdown
我的应用性能有问题，这是 Performance 测试结果【截图】，这是相关代码：

【贴上你的代码】

请帮我分析性能瓶颈，重点关注：
1. 有没有不必要的重新渲染？
2. 有没有重复的计算？
3. 数据结构选择是否合理？
4. 有没有可以并行的操作？
```

AI 会给你详细的分析和建议。



### 2、让 AI 提供优化方案

找到问题后，让 AI 给你具体的优化方案：

```markdown
这段代码在数据量大时很慢。请给我一个优化方案，要求：
1. 使用虚拟滚动
2. 保持代码可读性
3. 不改变现有的 API
4. 给出完整的实现代码
```

AI 会给你具体的优化代码，你可以直接使用。



### 3、分步骤优化

不要一次性实施所有优化。每次只优化一个地方，测试效果，确认有改善再继续。

比如：
1. 先优化最慢的部分（比如数据库查询）
2. 测试效果，确认有改善
3. 再优化第二慢的部分（比如图片加载）
4. 继续测试，确认有改善

这样即使某个优化出了问题，也容易回退。



### 4、验证优化效果

每次优化后，一定要验证效果。可以用 Performance 工具测量优化前后的性能，确保优化真的有效。

如果优化效果不明显，可以把测试结果反馈给 AI：

```markdown
我按你的方案优化了，但效果不明显，这是新的测试结果【截图】，还有其他优化方法吗？
```

AI 会根据新的数据给你更好的建议。



## 写在最后

性能优化是一个持续的过程，不是一次性的任务。随着项目发展，新的性能问题会不断出现，你需要持续关注和优化。

在 Vibe Coding 中，性能优化的核心是：**发现问题 → 描述需求 → 让 AI 实现 → 验证效果**。你不需要成为性能优化专家，只需要知道如何引导 AI 帮你解决问题。

让我总结一下本文的要点：

1. 先识别问题：用工具测量，找到真正的瓶颈，不要凭感觉。把测试结果给 AI 看，让它帮你分析。
2. 了解常见问题：AI 生成的代码容易出现这些性能问题 —— 不必要的渲染、大量数据一次性加载、图片未优化、串行请求、缺少缓存。知道这些问题，你就能更好地引导 AI。
3. 善用 AI：把性能问题描述清楚，让 AI 给你优化方案。分步骤实施，每次优化后都要验证效果。
4. 遵循原则：先测量再优化，优先优化影响最大的地方，不要过早优化，保持 MVP 思维。

记住，性能优化的目标不是追求极致的速度，而是给用户良好的体验。只要用户感觉快，就够了。

💡 如果你想更系统地学习性能优化，可以看看鱼皮在 [编程导航的项目](https://www.codefather.cn/post/1797431216467001345)，包含了丰富的性能优化实战，比如 [智能 BI 项目](https://www.codefather.cn/course/1790980531403927553) 讲解了异步化和消息队列优化，[智能面试刷题平台](https://www.codefather.cn/course/1826803928691945473) 讲解了 Redis 多级缓存和 Elasticsearch 搜索优化，[亿级流量点赞系统](https://www.codefather.cn/course/1912696290659577857) 更是专门讲解高并发、高性能、高可用的系统架构设计。

希望这些性能优化技巧能帮你让应用跑得更快，给用户带来更好的体验。

加油，冲冲冲！




## 推荐资源

1）鱼皮 AI 导航网站：[AI 资源大全、最新 AI 资讯、免费 AI 教程](https://ai.codefather.cn)

2）编程导航学习圈：[学习路线、编程教程、实战项目、求职宝典、交流答疑](https://www.codefather.cn)

3）程序员面试八股文：[实习/校招/社招高频考点、企业真题解析](https://www.mianshiya.com)

4）程序员写简历神器：[专业模板、丰富例句、直通面试](https://www.laoyujianli.com)

5）1 对 1 模拟面试：[实习/校招/社招面试拿 Offer 必备](https://ai.mianshiya.com)
